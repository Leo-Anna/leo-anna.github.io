<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二叉树</title>
    <url>/2021/12/26/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>二叉树的三种遍历方式</p>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val <span class="keyword">int</span></span><br><span class="line">	Left *TreeNode</span><br><span class="line">	Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	a:= []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> aTree *TreeNode</span><br><span class="line">	<span class="keyword">for</span> _,i :=<span class="keyword">range</span> a&#123;</span><br><span class="line">		aTree= insert(aTree,i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(aTree)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	res := threeOrders(aTree)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(t *TreeNode,value <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t ==<span class="literal">nil</span>&#123;</span><br><span class="line">		t = <span class="built_in">new</span>(TreeNode)</span><br><span class="line">		t.Val = value</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> value &gt; t.Val &#123;</span><br><span class="line">			t.Right = insert(t.Right,value)</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			t.Left =insert(t.Left,value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三种遍历方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeOrders</span><span class="params">( root *TreeNode )</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// write code here</span></span><br><span class="line">	<span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">	res  = <span class="built_in">make</span>([][]<span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">	PreOrder(root,&amp;res[<span class="number">0</span>])</span><br><span class="line">	MinOrder(root,&amp;res[<span class="number">1</span>])</span><br><span class="line">	PostOrder(root,&amp;res[<span class="number">2</span>])</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">PreOrder</span><span class="params">(t  *TreeNode,res *[]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	*res = <span class="built_in">append</span>(*res,t.Val)</span><br><span class="line">	PreOrder(t.Left,res)</span><br><span class="line">	PreOrder(t.Right,res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MinOrder</span><span class="params">(t  *TreeNode,res *[]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	MinOrder(t.Left,res)</span><br><span class="line">	*res = <span class="built_in">append</span>(*res,t.Val)</span><br><span class="line">	MinOrder(t.Right,res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostOrder</span><span class="params">(t  *TreeNode,res *[]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	PostOrder(t.Left,res)</span><br><span class="line">	PostOrder(t.Right,res)</span><br><span class="line">	*res = <span class="built_in">append</span>(*res,t.Val)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2021/12/26/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>包括数字转链表，翻转链表的几种方式（双链表，双指针）</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package services</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type ListNode struct &#123;</span><br><span class="line">   Val int</span><br><span class="line">   Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func ListPrint(a *ListNode)  &#123;</span><br><span class="line">   nowList := a</span><br><span class="line">   for&#123;</span><br><span class="line">      if nowList ==nil&#123;</span><br><span class="line">         fmt.Println(&quot;输出完成&quot;)</span><br><span class="line">         break</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(nowList.Val)</span><br><span class="line">      nowList = nowList.Next</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func SliceToList(s []int) *ListNode &#123;</span><br><span class="line">   // 数组转链表</span><br><span class="line">   nowList := new(ListNode)</span><br><span class="line">   head := nowList</span><br><span class="line">   for _,i := range s&#123;</span><br><span class="line">      temp := &amp;ListNode&#123;</span><br><span class="line">         Val:  i,</span><br><span class="line">         Next: nil,</span><br><span class="line">      &#125;</span><br><span class="line">      nowList.Next = temp</span><br><span class="line">      nowList = nowList.Next</span><br><span class="line">      head.Val ++</span><br><span class="line">   &#125;</span><br><span class="line">   return head.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @param pHead ListNode类</span><br><span class="line"> * @return ListNode类</span><br><span class="line"> */</span><br><span class="line">// 链表翻转 双指针</span><br><span class="line"></span><br><span class="line">func ReverseList1( pHead *ListNode ) *ListNode &#123;</span><br><span class="line">   // write code here</span><br><span class="line">   var pre *ListNode</span><br><span class="line">   pre = nil</span><br><span class="line">   cur := pHead</span><br><span class="line">   for &#123;</span><br><span class="line">      if cur == nil&#123;</span><br><span class="line">         break</span><br><span class="line">      &#125;</span><br><span class="line">      temp := cur.Next</span><br><span class="line">      cur.Next = pre</span><br><span class="line">      pre = cur</span><br><span class="line">      cur = temp</span><br><span class="line">   &#125;</span><br><span class="line">   return pre</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @param pHead ListNode类</span><br><span class="line"> * @return ListNode类</span><br><span class="line"> */</span><br><span class="line">// 链表翻转 双链表</span><br><span class="line"></span><br><span class="line">func ReverseList2( pHead *ListNode ) *ListNode &#123;</span><br><span class="line">   // write code here</span><br><span class="line">   newlist := new(ListNode)</span><br><span class="line">   newlist = nil</span><br><span class="line">   for&#123;</span><br><span class="line">      if pHead == nil&#123;</span><br><span class="line">         break</span><br><span class="line">      &#125;</span><br><span class="line">      head := &amp;ListNode&#123;</span><br><span class="line">         Val: pHead.Val,</span><br><span class="line">         Next:  newlist,</span><br><span class="line">      &#125;</span><br><span class="line">      newlist = head</span><br><span class="line">      pHead = pHead.Next</span><br><span class="line">   &#125;</span><br><span class="line">   return newlist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2021/12/26/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>两数之和</p>
<span id="more"></span>
<p><img src="https://gitee.com/leo_anna/image/raw/master/img//20211226154748.png" alt="image-20211226154748243"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * @param numbers int整型一维数组 </span></span><br><span class="line"><span class="comment">  * @param target int整型 </span></span><br><span class="line"><span class="comment">  * @return int整型一维数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">( numbers []<span class="keyword">int</span> ,  target <span class="keyword">int</span> )</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">	key := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> index,value := <span class="keyword">range</span> numbers&#123;</span><br><span class="line">			ret1,ok := key[target-value]</span><br><span class="line">			<span class="keyword">if</span> !ok&#123;</span><br><span class="line">				key[value] = index</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				res = <span class="built_in">append</span>(res,ret1+<span class="number">1</span>,index+<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解释：a+b=c,则a、b必然存在列表中，所以遍历一遍列表，并判重字典就可以了</p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>两数之和</tag>
      </tags>
  </entry>
  <entry>
    <title>用两个栈实现队列</title>
    <url>/2021/12/27/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><img src="https://gitee.com/leo_anna/image/raw/master/img//20211227210926.gif" alt="fig1"></p>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;container/list&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> CQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">   stack1,stack2 *list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">CQueue</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> CQueue&#123;</span><br><span class="line">      stack1: list.New(),</span><br><span class="line">      stack2: list.New(),</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CQueue)</span> <span class="title">AppendTail</span><span class="params">(value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">   this.stack1.PushBack(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CQueue)</span> <span class="title">DeleteHead</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> this.stack2.Len()==<span class="number">0</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> this.stack1.Len()!=<span class="number">0</span> &#123;</span><br><span class="line">         this.stack2.PushBack(this.stack1.Remove(this.stack1.Back()))</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//删除栈底元素</span></span><br><span class="line">   <span class="keyword">if</span> this.stack2.Len() !=<span class="number">0</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> this.stack2.Remove(this.stack2.Back()).(<span class="keyword">int</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.AppendTail(value);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.DeleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙跳台问题</title>
    <url>/2021/12/27/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>可以转换成斐波那契数列问题</p>
<p>解题思路：</p>
<blockquote>
<p>此类求 <em>多少种可能性</em> 的题目一般都有 <strong>递推性质</strong> ，即 f(n)<em>f</em>(<em>n</em>) 和 f(n-1)<em>f</em>(<em>n</em>−1)…f(1)<em>f</em>(1) 之间是有联系的。</p>
</blockquote>
<span id="more"></span>
<p><img src="https://gitee.com/leo_anna/image/raw/master/img//20211227222058.png" alt="image-20211227222058701">方法：</p>
<ul>
<li>递归法</li>
<li>记忆递归法，需要额外申请一个空间存放历史数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numWays</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a:= <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">return</span> Jump(n,a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Jump</span><span class="params">(n <span class="keyword">int</span>,a <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">2</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	sum,ok:= a[n]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">		a[n] = Jump(n<span class="number">-1</span>,a)+Jump(n<span class="number">-2</span>,a)</span><br><span class="line">		<span class="keyword">return</span> a[n]%<span class="number">1000000007</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态规划 最佳</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numWays</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	pre,now := <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++&#123;</span><br><span class="line">		pre,now= now,(pre+now)%<span class="number">1000000007</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>菲波那切数列</tag>
      </tags>
  </entry>
  <entry>
    <title>面试八股文 linux 篇</title>
    <url>/2021/12/26/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%20linux%20%E7%AF%87/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>八股文</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 日记 2021.12.24</title>
    <url>/2021/12/24/mysql-%E6%97%A5%E8%AE%B0-2021.12.24/</url>
    <content><![CDATA[<h3 id="mysql-sql执行流程"><a href="#mysql-sql执行流程" class="headerlink" title="mysql sql执行流程"></a>mysql sql执行流程</h3><span id="more"></span>

<img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img" style="zoom: 33%;" />

<h3 id="redo-log和binlog"><a href="#redo-log和binlog" class="headerlink" title="redo log和binlog"></a>redo log和binlog</h3><p>二者的理解可以通过记账老板记账过程中使用的粉板和记账本</p>
<p>二者日志都先是写到磁盘中，然后根据参数配置持久化磁盘中的（redolog 对应innodb_flush_log_at_trx_commit， binlog对应sync_binlog）</p>
<img src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="img" style="zoom:33%;" />

<h4 id="redolog重做日志"><a href="#redolog重做日志" class="headerlink" title="redolog重做日志"></a>redolog重做日志</h4><ul>
<li>内存更新后写入，提交时候时写入</li>
<li>定期刷脏页，推进pos点，刷脏页的情况有redolog满了、正常关机、内存满了、空闲刷</li>
<li>和binlog一起使用，两阶段提交，不能单独写完一个再去写另一个，原因是为了保证二者状态的逻辑一致性（一条sql在两个日志上的状态保持一致）<ul>
<li>反证法解析<ul>
<li>写完binlog，再去写redo log，写完第一个后crash，在binlog这边就意味着比redolog多了一个事务，redolog还没写，意味着还没落盘，如果存在主从同步，会产生数据不一致</li>
<li>写完redo log，再去写binlog，写完redo log crash ，重启恢复数据根据redo log，成功恢复数据为最新的，但是binlog中没有这个事务，存在主从同步的话，也会存在产生数据不一致</li>
</ul>
</li>
</ul>
</li>
<li>innodb存储层实现</li>
<li>循环写、顺序写，不能替代binlog</li>
<li>实现了carsh-safe的能力</li>
<li>物理日志，记录数据页上的实际变更操作</li>
</ul>
<h4 id="binlog归档日志"><a href="#binlog归档日志" class="headerlink" title="binlog归档日志"></a>binlog归档日志</h4><ul>
<li>server层实现</li>
<li>有三种格式statment 、rows、mixed，一般为rows</li>
<li>逻辑日志，记录变更原始逻辑</li>
</ul>
<h3 id="唯一索引和普通索引"><a href="#唯一索引和普通索引" class="headerlink" title="唯一索引和普通索引"></a>唯一索引和普通索引</h3><ul>
<li><p>唯一索引的查询效率是<strong>略高于</strong>普通索引的</p>
</li>
<li><p>从磁盘中读数据到内存中是按照数据页page来读取的</p>
</li>
</ul>
<h4 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h4><ul>
<li>普通索引会使用到change buffer 来优化更新语句，提高很高的性能，但是不适合写多读少的情况，尤其是写完数据再去读这条数据，会增加change buffer的维护成本</li>
<li>唯一索引由于需要判断唯一性所以不能用change buffer，所以一般情况下建议使用普通索引，尤其是表量大的情况</li>
<li>change buffer 是可以持久化的</li>
<li>包括insert、update、delete操作</li>
<li>更新后的select<ul>
<li>如果是在内存中更新，则直接返回</li>
<li>merge操作，如果是change buffer 中缓存，则从磁盘中读出数据，导入change buffer中的操作日志，生成一个数据版本，返回</li>
</ul>
</li>
</ul>
<h4 id="change-buffer和redolog"><a href="#change-buffer和redolog" class="headerlink" title="change buffer和redolog"></a>change buffer和redolog</h4><ul>
<li>change buffer 节省的是随机读磁盘的io</li>
<li>redlog 节省的是随机写磁盘的io，转换成顺序写</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>redolog和binlog</tag>
        <tag>change buffer</tag>
      </tags>
  </entry>
  <entry>
    <title>面试八股文 计网篇</title>
    <url>/2021/12/26/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%20%E8%AE%A1%E7%BD%91%E7%AF%87/</url>
    <content><![CDATA[<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="各层协议"><a href="#各层协议" class="headerlink" title="各层协议"></a>各层协议</h3><ul>
<li><p>应用层：HTTP、FTP、SMTP、BOOTP、DHCP、TFTP、SOCKS（安全套接字协议）</p>
</li>
<li><p>表示层：信息语法语义以及他们的关联，如加密解密、转换翻译、压缩解压缩</p>
</li>
<li><p>会话层：不同机器的用户之间建立以及管理会话，SSL（安全套接字协议）、TLS（传输层安全协议）</p>
</li>
<li><p>传输层：接受上一次层的数据，分割处理，交给网络层，TCP、UDP</p>
</li>
<li><p>网络层：控制子网的运行，逻辑编址、分组传输、路由选择，IP、IPv6、EGP（外部网关协议）、IGRP（内部网关协议）、RIP、OSPF、BGP、ICMP、IGMP（组管理协议）</p>
</li>
<li><p>数据链路层：物理寻址，将原始比特流转变成逻辑传输线路，ARP、RARP、</p>
</li>
<li><p>物理层：原始比特流传输，IEEE802.2、Ethernet v.2 Internetwork222</p>
</li>
</ul>
<span id="more"></span>





<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul>
<li>向上层提供服务</li>
<li>无连接</li>
<li>尽最大努力交付的数据报</li>
<li>点到点</li>
</ul>
<h4 id="主要协议"><a href="#主要协议" class="headerlink" title="主要协议"></a>主要协议</h4><ul>
<li>ip/ipv6 </li>
<li>ICMP 互联网控制信息协议</li>
<li>EGP 外部网关协议</li>
<li>OSPF 开放最短路径优先协议</li>
<li>IGRP 内部网关协议</li>
<li>RIP2 路由信息协议</li>
</ul>
<h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>屏蔽底层物理网络协议差异，实现异构网络互连</p>
<ul>
<li>无连接投递机制</li>
<li>不保证数据报文传输的可靠性</li>
<li>   提供尽最大努力的投递机制</li>
</ul>
<h5 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a><strong>报文格式</strong></h5><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" width="700"/> </div><br>

<ul>
<li><p>  <strong>版本</strong>   : 有 4（IPv4）和 6（IPv6）两个值；</p>
</li>
<li><p>  <strong>首部长度</strong>   : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。<strong>首部最大长度60字节</strong></p>
</li>
<li><p>  <strong>区分服务</strong>   : 用来获得更好的服务，一般情况下不使用。</p>
</li>
<li><p>  <strong>总长度</strong>   : 包括首部长度和数据部分长度。<strong>ip数据报最大长度65535=64k</strong></p>
</li>
<li><p>  <strong>生存时间</strong>   ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p>
</li>
<li><p>  <strong>协议</strong>  ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p>
</li>
<li><p>  <strong>首部检验和</strong>  ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p>
</li>
<li><p>  <strong>标识</strong>   : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p>
</li>
<li><p>  <strong>片偏移</strong>   : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p>
</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23ba890e-e11c-45e2-a20c-64d217f83430.png" width="700"/> </div><br>

<h5 id="分片重组"><a href="#分片重组" class="headerlink" title="分片重组"></a><strong>分片重组</strong></h5><p>分片重组：标识、标志、片偏移量</p>
<ul>
<li>目的主机重组完成后交付上层协议</li>
<li>标识：识别属于哪一个原始数据报</li>
<li>标志：MF 是否还有分片 DF 是否可以分片</li>
</ul>
<h5 id="FreeBSD分片重组算法：思想"><a href="#FreeBSD分片重组算法：思想" class="headerlink" title="FreeBSD分片重组算法：思想"></a><strong>FreeBSD分片重组算法</strong>：思想</h5><p>1.每收到一个IP数据报，算法首先检查其MF位及偏移量的值：<br>（1）如果二者至少有一个不为0，说明这是一个需要重组的分片；<br>2.检查其ID：<br>（1）如果未出现在已有的ipq链表中，则说明是一个新的数据报，此时重组算法会分配一个新的ipq和ipasfrag结构；<br>（2）如果不是新的数据报，则重组算法根据其源IP地址、目的IP地址、协议、ID及偏移量字段将其插入链表适当的位置；<br>3.每次插入一个新的分片，重组算法都会重新计算已经收到的数据长度，并与总长度对比：<br>（1）如果已经达到了总长度，说明所有分片都已到达，此时可以进行数据合并，并将报头附加在数据的前边；<br>4.删除链表中相应的结构。</p>
<h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><ul>
<li>传递控制信息<ul>
<li>拥塞控制</li>
<li>选路优化</li>
<li>目的地可达性判断</li>
<li>时钟同步</li>
</ul>
</li>
<li>提供差错报告<ul>
<li>循环投递</li>
<li>分片丢失</li>
<li>投递失败</li>
</ul>
</li>
<li>传递控制信息+提供差错报告=ICMP</li>
</ul>
<p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" width="500"/> </div><br>

<p>ICMP 报文分为差错报告报文和询问报文。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" width="600"/> </div><br>

<p><strong>应用</strong></p>
<ul>
<li><p>ping，测试主机连通性</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
</li>
<li><p>traceroute</p>
<p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间==超过差错报告报文==；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP ==时间超过差错报文==。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ==ICMP 终点不可达差错报告报文==。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
</li>
</ul>
<h4 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h4><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<p>有三个专用地址块：</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
<p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p>
<p><strong>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信</strong></p>
<ul>
<li><p>IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。</p>
</li>
<li><p>数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。</p>
</li>
<li><p>路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p>
</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1556770b-8c01-4681-af10-46f1df69202c.jpg" width="800"/> </div><br>

<h4 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h4><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p>
<ul>
<li><p>只能由专有网络的主机发起链接</p>
</li>
<li><p>NATip报文转发属于网络层，查看和转换端口号属于传输层</p>
</li>
</ul>
<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2719067e-b299-4639-9065-bed6729dbf0b.png" width=""/> </div><br>



<h4 id="路由转发"><a href="#路由转发" class="headerlink" title="路由转发"></a>路由转发</h4><ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1ab49e39-012b-4383-8284-26570987e3c4.jpg" width="800"/> </div><br>

<h4 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h4><h5 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h5><ul>
<li>属于内部网关协议</li>
<li>适合小规模网络</li>
<li>使用向量距离算法，通告路由信息（目的地址，距离）</li>
<li>使用udp端口520</li>
<li>周期性向相邻路由通告本地路i有信息，response传送</li>
<li>rip路由器分主动型（Active）和被动型（Passive），主机只能选择被动型</li>
</ul>
<p><strong>向量距离算法</strong></p>
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ul>
<p><strong>慢收敛问题</strong></p>
<p><img src="https://gitee.com/Leo_Anna/image/raw/master/img//20200909112920.png" alt="image-20200909112917814"></p>
<p>解决：</p>
<p>1.简单分割范围法：当路由器向一个接口发送路由更新报文时，其中不包含从该接口获取的路径信息。<br>2.<strong>带毒性逆转的分割范围法</strong>：当路由器向一个接口发送路由更新报文时，如果某个条目是通过该接口获得的，则将该条目的距离设置为无穷大。<br>3.抑制法：所有路由器在收到某个网络不可达的消息后，将相应表项的距离值置为16，并将此信息保留一段时间（坏消息保留时间默认60秒）。<br>4.触发更新法：一旦发现网络连接消失，就将该网络设置为不可达，并立即发送路由更新报文，而不等待正常的路由更新周期时间到。</p>
<p>总结：RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器<strong>（慢收敛问题）</strong>。</p>
<h5 id="ospf"><a href="#ospf" class="headerlink" title="ospf"></a>ospf</h5><ul>
<li><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的，适合大规模网络。</p>
</li>
<li><p>基于ip</p>
</li>
<li><p>思想：将一个大规模网络划分为多个易于管理的区域，缩小交换链路状态数据的路由器群组规模</p>
</li>
<li><p>最短路径优先使用了SPF</p>
</li>
</ul>
<p><strong>路由器分类</strong></p>
<ul>
<li><p>内部路由器IR</p>
</li>
<li><p>区域边界路由器ABR</p>
</li>
<li><p>骨干路由器BR</p>
</li>
<li><p>自制系统边界路由器 ASBR</p>
</li>
<li><p>区域分类（骨干区个非骨干）</p>
</li>
</ul>
<p><strong>OSPF 具有以下特点：</strong></p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
</ul>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p>
<h5 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h5><ul>
<li>边界网关协议，AS之间路由信息交换</li>
<li>基于TCP，端口号179</li>
<li>BGP发言人通告路由信息经过聚类后的可达性路由信息，以降低路由规模和隐藏网络拓扑结构</li>
</ul>
<p><strong>AS 之间的路由选择很困难，主要是由于</strong>：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png" width="600"/> </div><br>

<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。</p>
<p>传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p>
<h4 id="TCP和UDP的特点区别"><a href="#TCP和UDP的特点区别" class="headerlink" title="TCP和UDP的特点区别"></a>TCP和UDP的特点区别</h4><ul>
<li>用户数据包协议udp<ul>
<li>无连接</li>
<li>最近大可能交付</li>
<li>没有拥塞控制</li>
<li>面向报文，对于应用程序传下来的报文不合并也不拆分，只添加udp头部</li>
<li>支持一对一，一对多，多对一，多对多的通信方式</li>
</ul>
</li>
<li>传输控制协议tcp<ul>
<li>面向连接</li>
<li>提供可靠交付，有流量控制，拥塞控制，</li>
<li>提供全双工通信，面向字节流（对于应用层传下来的报文堪称字节流，把字节流组成大小不等的数据块）</li>
<li>只能点对点，一对一</li>
</ul>
</li>
</ul>
<h4 id="问题：为什莫TCP传输比UDP慢"><a href="#问题：为什莫TCP传输比UDP慢" class="headerlink" title="问题：为什莫TCP传输比UDP慢"></a>问题：为什莫TCP传输比UDP慢</h4><ul>
<li>udp首部8，TCP首部20</li>
<li>tcp数据块分组</li>
<li>tcp要先三次握手建立连接</li>
<li><strong>主要原因：TCP有发送确认机制，反馈信息占用一部分带宽资源</strong></li>
</ul>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p><strong>UDP 首部格式</strong></p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" width="600"/> </div><br>

<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。</p>
<p>12 字节的伪首部是为了计算检验和临时添加的。</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><h5 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a><strong>首部格式</strong></h5><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" width="700"/> </div><br>

<ul>
<li><p>  <strong>序号</strong>   ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
</li>
<li><p>  <strong>确认号</strong>   ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，==因此 B 期望下一个报文段的序号为 701==，B 发送给 A 的确认报文段中确认号就为 701。</p>
</li>
<li><p>  <strong>数据偏移</strong>   ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
</li>
<li><p>  <strong>确认 ACK</strong>   ：当 ACK=1 时确认号字段有效，否则无效。==TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1==。</p>
</li>
<li><p>  <strong>同步 SYN</strong>   ：在连接建立时用来同步序号。==当 SYN=1，ACK=0== 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
</li>
<li><p>  <strong>终止 FIN</strong>   ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
</li>
<li><p>  <strong>窗口</strong>   ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
</li>
</ul>
<h5 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h5><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png" width="600"/> </div><br>

<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p>
</li>
<li><p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p>
</li>
<li><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p>
</li>
<li><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，==确认号为 y+1，序号为 x+1==。</p>
</li>
<li><p>B 收到 A 的确认后，连接建立。</p>
</li>
</ul>
<p><strong>三次握手的原因</strong>  </p>
<p>==第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接==。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，<strong>如果不进行三次握手，那么服务器就会打开两个连接</strong>。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<h5 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h5><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" width="600"/> </div><br>

<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li><p>A 发送连接释放报文，FIN=1。</p>
</li>
<li><p>B 收到之后发出确认，<strong>此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据</strong>。</p>
</li>
<li><p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p>
</li>
<li><p>A 收到后发出确认，进入 TIME-WAIT 状态，<strong>等待 2 MSL（最大报文存活时间）后释放连接。</strong></p>
</li>
<li><p>B 收到 A 的确认后释放连接。</p>
</li>
</ul>
<p><strong>四次挥手的原因</strong>  </p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 ==CLOSE-WAIT 状态==。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>TIME_WAIT</strong>  </p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li><p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p>
</li>
<li><p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p>
</li>
</ul>
<h5 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h5><p>TCP使用超时重传实现可靠传输：如果一个已经发送的报文在超时时间内没有收到确认，那么重传这个报文段</p>
<p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p>
<div align="center"><img src="https://latex.codecogs.com/gif.latex?RTTs=(1-a)*(RTTs)+a*RTT" class="mathjax-pic"/></div> <br>

<p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p>
<p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p>
<div align="center"><img src="https://latex.codecogs.com/gif.latex?RTO=RTTs+4*RTT_d" class="mathjax-pic"/></div> <br>

<p>其中 RTT<sub>d</sub> 为偏差的加权平均值。</p>
<h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><ul>
<li>思想：允许在一个分组确认到达之前发送多个分组</li>
</ul>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，<strong>直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</strong></p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<p><img src="https://gitee.com/Leo_Anna/image/raw/master/img//20200914104709.png" alt="image-20200914104707367"></p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" width="800"/> </div><br>

<h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>
<p>接收方发送的==确认报文中的窗口字段==可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。</p>
<p><strong>流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</strong></p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" width="500"/> </div><br>

<p>TCP 主要通过四个算法来进行拥塞控制==慢开始、拥塞避免、快重传、快恢复==。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p>为了便于讨论，做如下假设：</p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/910f613f-514f-4534-87dd-9b4699d59d31.png" width="800"/> </div><br>

<ol>
<li><strong>慢开始与拥塞避免</strong></li>
</ol>
<p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
<ol start="2">
<li><strong>快重传与快恢复</strong></li>
</ol>
<p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p>
<p>==在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失==，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" width="600"/> </div><br>

]]></content>
      <categories>
        <category>八股文</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>面试八股文 mysql篇</title>
    <url>/2021/12/28/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%20mysql%E7%AF%87/</url>
    <content><![CDATA[<h3 id="mysql面试的八股文，持续更新"><a href="#mysql面试的八股文，持续更新" class="headerlink" title="mysql面试的八股文，持续更新"></a>mysql面试的八股文，持续更新</h3><span id="more"></span>

<h3 id="连接器的最大连接数以及调优"><a href="#连接器的最大连接数以及调优" class="headerlink" title="连接器的最大连接数以及调优"></a>连接器的最大连接数以及调优</h3><p>mysql服务器最大支持max_connect 为 16384</p>
<p>根据需求来看，一般2核4G机器填写1000，16核64G填写5000。</p>
<h3 id="刷脏页-参数"><a href="#刷脏页-参数" class="headerlink" title="刷脏页 参数"></a>刷脏页 参数</h3><p> innodb_io_capacity 表示磁盘的io能力，控制了刷脏页的速度</p>
<p>innodb_max_dirty_pages_pct 脏页比例阈值，达到这个值就开始刷脏页</p>
<p>脏页比例计算 Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total</p>
<h3 id="redolog和binlog区别"><a href="#redolog和binlog区别" class="headerlink" title="redolog和binlog区别"></a>redolog和binlog区别</h3><ul>
<li>redolog innodb存储层，binlog server层</li>
<li>redolog 是物理日志，记录的语句在内存中执行了什么动作，binlog是逻辑日志，记录了语句的原始逻辑</li>
<li>先写内存，再写redolog prepare 再写binlog 再写redolog commit</li>
</ul>
<h3 id="redolog和binlog-刷盘参数"><a href="#redolog和binlog-刷盘参数" class="headerlink" title="redolog和binlog 刷盘参数"></a>redolog和binlog 刷盘参数</h3><p>控制binlog 把binlog cache 刷到磁盘的时机：sync_binlog</p>
<ul>
<li>sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；</li>
<li>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</li>
<li>sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<p>binlog 组提交优化参数：binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count</p>
<p>控制redolog把logbuffer 写入 oscache 和刷盘的时机： innodb_flush_log_at_trx_commit </p>
<ul>
<li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li>
<li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li>
<li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li>
</ul>
<h3 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h3><h3 id="sql执行流程"><a href="#sql执行流程" class="headerlink" title="sql执行流程"></a>sql执行流程</h3><ul>
<li>连接器，权限校验，连接池</li>
<li>查询缓存，直接返回</li>
<li>分析器，分析语法语义是否合规，正确</li>
<li>优化器，优化sql，选择合适索引</li>
<li>执行器，调用存储引擎api，执行语句，要什么，存储引擎给什么</li>
<li>存储引擎，从内存和磁盘中找到sql执行结果，返回执行器</li>
</ul>
<h3 id="mvcc"><a href="#mvcc" class="headerlink" title="mvcc"></a>mvcc</h3><h3 id="mha"><a href="#mha" class="headerlink" title="mha"></a>mha</h3><h3 id="为什么要用b-tree，其他可以用的数据结构都有哪些"><a href="#为什么要用b-tree，其他可以用的数据结构都有哪些" class="headerlink" title="为什么要用b+tree，其他可以用的数据结构都有哪些"></a>为什么要用b+tree，其他可以用的数据结构都有哪些</h3><p>索引的常用<strong>数据结构</strong>：</p>
<ol>
<li>二叉树</li>
<li>红黑树</li>
<li>Hash 表</li>
<li><code>B-tree</code> （B树，并不叫什么B减树😁）</li>
<li><code>B+tree</code></li>
</ol>
<h3 id="说一说三大范式"><a href="#说一说三大范式" class="headerlink" title="说一说三大范式"></a>说一说三大范式</h3><ul>
<li><strong>「第一范式」</strong>：数据库中的字段具有<strong>「原子性」</strong>，不可再分，并且是单一职责</li>
<li><strong>「第二范式」</strong>：<strong>「建立在第一范式的基础上」</strong>，第二范式要求数据库表中的每个实例或行必须<strong>「可以被惟一地区分」</strong>。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键</li>
<li><strong>「第三范式」</strong>：<strong>「建立在第一，第二范式的基础上」</strong>，确保每列都和主键列直接相关，而不是间接相关不存在其他表的非主键信息</li>
</ul>
<p>但是在我们的日常开发当中，<strong>「并不是所有的表一定要满足三大范式」</strong>，有时候冗余几个字段可以少关联几张表，带来的查询效率的提升有可能是质变的</p>
<h3 id="MyISAM-与-InnoDB-的区别是什么？"><a href="#MyISAM-与-InnoDB-的区别是什么？" class="headerlink" title="MyISAM 与 InnoDB 的区别是什么？"></a>MyISAM 与 InnoDB 的区别是什么？</h3><img src="https://img-blog.csdnimg.cn/img_convert/e42a8e4a50675fbe6540fb3558986add.png" alt="e42a8e4a50675fbe6540fb3558986add.png" style="zoom:50%;" />

<ul>
<li><p><strong>「InnoDB支持事务，MyISAM不支持」</strong>。</p>
</li>
<li><p><strong>「InnoDB 支持外键，而 MyISAM 不支持」</strong>。</p>
</li>
<li><p><strong>「InnoDB是聚集索引」</strong>，使用B+Tree作为索引结构，数据文件是和索引绑在一起的，必须要有主键。<strong>「MyISAM是非聚集索引」</strong>，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p>
</li>
<li><p><strong>「InnoDB 不保存表的具体行数」</strong>。<strong>「MyISAM 用一个变量保存了整个表的行数」</strong>。</p>
</li>
<li><p>Innodb 有 <strong>「redolog」</strong> 日志文件，MyISAM 没有</p>
</li>
<li><p><strong>「Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI」</strong></p>
</li>
</ul>
<ul>
<li>Innodb：frm是表定义文件，ibd是数据文件</li>
<li>Myisam：frm是表定义文件，myd是数据文件，myi是索引文件</li>
<li><strong>「InnoDB 支持表、行锁，而 MyISAM 支持表级锁」</strong></li>
<li><em>「InnoDB 必须有唯一索引(主键)」</em><em>,如果没有指定的话 InnoDB 会自己生成一个隐藏列Row_id来充当默认主键，*<em>「MyISAM 可以没有」</em></em></li>
</ul>
<h3 id="为什么推荐使用自增-id-作为主键？"><a href="#为什么推荐使用自增-id-作为主键？" class="headerlink" title="为什么推荐使用自增 id 作为主键？"></a>为什么推荐使用自增 id 作为主键？</h3><img src="https://img-blog.csdnimg.cn/img_convert/69a8346941af33b8ceded3fcafe0ce03.png" alt="69a8346941af33b8ceded3fcafe0ce03.png" style="zoom:50%;" />

<ul>
<li>１.普通索引的 B+ 树上存放的是主键索引的值，如果该值较大，会<strong>「导致普通索引的存储空间较大」</strong></li>
<li>２.使用自增 id 做主键索引新插入数据只要放在该页的最尾端就可以，直接<strong>「按照顺序插入」</strong>，不用刻意维护</li>
<li>3.页分裂容易维护，当插入数据的当前页快满时，会发生页分裂的现象，如果主键索引不为自增 id，那么数据就可能从页的中间插入，页的数据会频繁的变动，<strong>「导致页分裂维护成本较高」</strong></li>
</ul>
<h3 id="一条查询语句是怎么执行的"><a href="#一条查询语句是怎么执行的" class="headerlink" title="一条查询语句是怎么执行的?"></a>一条查询语句是怎么执行的?</h3><img src="https://img-blog.csdnimg.cn/img_convert/eb4e297a05891f2cdcfd9990f89e483a.png" alt="eb4e297a05891f2cdcfd9990f89e483a.png" style="zoom:50%;" />

<ul>
<li>通过连接器跟客户端<strong>「建立连接」</strong></li>
<li>通过查询<strong>「缓存查询」</strong>之前是否有查询过该 sql<ul>
<li>有则直接返回结果</li>
<li>没有则执行第三步</li>
</ul>
</li>
<li>通过分析器<strong>「分析该 sql 的语义」</strong>是否正确，包括格式，表等等</li>
<li>通过优化器<strong>「优化该语句」</strong>，比如选择索引，join 表的连接顺序</li>
<li><strong>「验证权限」</strong>，验证是否有该表的查询权限<ul>
<li>没有则返回无权限的错误</li>
<li>有则执行第六步</li>
</ul>
</li>
<li>通过执行器调用存储引擎执行该 sql，然后返回<strong>「执行结果」</strong></li>
</ul>
<h3 id="使用-Innodb-的情况下，一条更新语句是怎么执行的"><a href="#使用-Innodb-的情况下，一条更新语句是怎么执行的" class="headerlink" title="使用 Innodb 的情况下，一条更新语句是怎么执行的?"></a>使用 Innodb 的情况下，一条更新语句是怎么执行的?</h3><p>用以下语句来举例，c 字段无索引，id 为主键索引（无其他索引，有普通索引和唯一索引情况会发生变化，有了change buffer/insert buffer的优化）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">update T set c=c+<span class="number">1</span> where id=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行器先找引擎取 id=2 这一行。id 是主键，引擎直接用树搜索找到这一行<ul>
<li>如果 id=2 这一行所在的数据页本来就<strong>「在内存中」</strong>，就<strong>「直接返回」</strong>给执行器</li>
<li><strong>「不在内存」</strong>中，需要先从磁盘<strong>「读入内存」</strong>，然后再<strong>「返回」</strong></li>
</ul>
</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口<strong>「写入这行新数据」</strong></li>
<li>擎将这行新数据更新到内存中，同时将这个更新操作<strong>「记录到 redo log 里面」</strong>，此时 redo log 处于 <strong>「prepare」</strong> 状态。然后告知执行器执行完成了，随时可以提交事务</li>
<li>执行器<strong>「生成这个操作的 binlog」</strong>，并把 binlog <strong>「写入磁盘」</strong></li>
<li>执行器调用引擎的<strong>「提交事务」</strong>接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，<strong>「更新完成」</strong></li>
</ul>
<h3 id="Innodb-事务为什么要两阶段提交"><a href="#Innodb-事务为什么要两阶段提交" class="headerlink" title="Innodb 事务为什么要两阶段提交?"></a>Innodb 事务为什么要两阶段提交?</h3><p>目的：保持redolog和binlog的状态一致性，进而保证了主从一致性</p>
<ul>
<li>先写 redolog 后写binlog。假设在 redolog 写完，binlog 还没有写完的时候，MySQL 进程异常重启，这时候 binlog 里面就没有记录这个语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 <strong>「binlog 丢失」</strong>，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li>
<li>先写 binlog 后写 redolog。如果在 binlog 写完之后 crash，由于 redolog 还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是 binlog 里面已经记录了“把c从0改成1”这个日志。所以，在之后用 binlog 来恢复的时候就<strong>「多了一个事务出来」</strong>，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li>
</ul>
<p>可以看到，<strong>「如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致」</strong>。</p>
<h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引?"></a>什么是索引?</h3><p>相信大家小时候学习汉字的时候都会查字典，想想你查字典的步骤，我们是通过汉字的首字母 a～z 一个一个在字典目录中查找，最终找到该字的页数。想想，如果没有目录会怎么样，最差的结果是你有可能翻到字典的最后一页才找到你想要找的字。</p>
<p>索引就<strong>「相当于我们字典中的目录」</strong>，可以极大的提高我们在数据库的查询效率。</p>
<h3 id="索引失效的场景有哪些"><a href="#索引失效的场景有哪些" class="headerlink" title="索引失效的场景有哪些?"></a>索引失效的场景有哪些?</h3><p>以下随便列举几个，不同版本的 mysql 场景不一</p>
<ul>
<li>最左前缀法则（带头索引不能死，中间索引不能断)</li>
<li>不要在索引上做任何操作（计算、函数、自动/手动类型转换），不然会导致索引失效而转向全表扫描</li>
<li>不能继续使用索引中范围条件（bettween、&lt;、&gt;、in等）右边的列，如：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a from user where c &gt; <span class="number">5</span> and b = <span class="number">4</span>；</span><br></pre></td></tr></table></figure>

<ul>
<li>索引字段上使用（！= 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描</li>
<li>索引字段上使用 is null / is not null 判断时，会导致索引失效而转向全表扫描。</li>
<li>索引字段使用like以通配符开头（‘%字符串’）时，会导致索引失效而转向全表扫描，也是最左前缀原则。</li>
<li>索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描</li>
<li>索引字段使用 or 时，会导致索引失效而转向全表扫描</li>
</ul>
<h3 id="为什么采用-B-树-而不是-B-树"><a href="#为什么采用-B-树-而不是-B-树" class="headerlink" title="为什么采用 B+ 树,而不是 B-树"></a>为什么采用 B+ 树,而不是 B-树</h3><p>B+ 树只在叶子结点储存数据，非叶子结点不存具体数据，只存 key，查询更稳定，增大了广度，而一个节点就是磁盘一个内存页，内存页大小固定，那么相比 B 树，B- 树这些<strong>「可以存更多的索引结点」</strong>，宽度更大，树高矮，节点小，拉取一次数据的磁盘 IO 次数少，并且 B+ 树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，效率更高。</p>
<h3 id="WAl-是什么-有什么好处"><a href="#WAl-是什么-有什么好处" class="headerlink" title="WAl 是什么?有什么好处?"></a>WAl 是什么?有什么好处?</h3><p>先写日志，在写磁盘</p>
<p>WAL 就是 Write-Ahead Logging，其实就是<strong>「所有的修改都先被写入到日志中，然后再写磁盘」</strong>，用于保证数据操作的原子性和持久性。</p>
<p>好处:</p>
<ul>
<li><strong>「读和写可以完全地并发执行」</strong>，不会互相阻塞</li>
<li>先写入 log 中，磁盘写入从<strong>「随机写变为顺序写」</strong>，降低了 client 端的延迟就。并且，由于顺序写入大概率是在一个磁盘块内，这样产生的 io 次数也大大降低</li>
<li>写入日志当数据库崩溃的时候<strong>「可以使用日志来恢复磁盘数据」</strong></li>
</ul>
<h3 id="什么是回表"><a href="#什么是回表" class="headerlink" title="什么是回表?"></a>什么是回表?</h3><img src="https://img-blog.csdnimg.cn/img_convert/b7ac1234b2d44d81bf17dee1c95d4d37.png" alt="b7ac1234b2d44d81bf17dee1c95d4d37.png" style="zoom:67%;" />

<p>回表就是先通过数据库索引扫描出该索引树中数据所在的行，取到主键 id，再通过主键 id 取出主键索引数中的数据，即基于非主键索引的查询需要多扫描一棵索引树.</p>
<h3 id="什么是索引下推"><a href="#什么是索引下推" class="headerlink" title="什么是索引下推?"></a>什么是索引下推?</h3><p>如果存在某些被索引的列的判断条件时，MySQL 将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合 MySQL 服务器传递的条件，<strong>「只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器」</strong> 。</p>
<p>就是<strong>一般情况</strong>下，索引列中存在的字段，并且存在where 判断，都可以被利用到，无论是否满足索引使用规则</p>
<h3 id="什么是覆盖索引"><a href="#什么是覆盖索引" class="headerlink" title="什么是覆盖索引?"></a>什么是覆盖索引?</h3><p>覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取，可以减少回表的次数。比如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id from t where age = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>id 为主键索引，age 为普通索引，age 这个索引树存储的就是逐渐信息，可以直接返回</p>
<h3 id="什么是最左前缀原则"><a href="#什么是最左前缀原则" class="headerlink" title="什么是最左前缀原则?"></a>什么是最左前缀原则?</h3><p>最左前缀其实说的是，在 where 条件中出现的字段，<strong>「如果只有组合索引中的部分列，则这部分列的触发索引顺序」</strong>，是按照定义索引的时候的顺序从前到后触发，最左面一个列触发不了，之后的所有列索引都无法触发。</p>
<p>比如<strong>「有一个 (a,b,c) 的组合索引」</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">where a = <span class="number">1</span> and b = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>此时 a,b 会命中该组合索引</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">where a = <span class="number">1</span> and c = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>此时 a 会命中该组合索引, c 不会</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">where b = <span class="number">1</span> and c = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>此时不会命中该组合索引</p>
<h3 id="普通索引和唯一索引该怎么选择"><a href="#普通索引和唯一索引该怎么选择" class="headerlink" title="普通索引和唯一索引该怎么选择?"></a>普通索引和唯一索引该怎么选择?</h3><ul>
<li>查询<ul>
<li>当普通索引为条件时查询到数据会一直扫描,直到扫到不同的值</li>
<li>当唯一索引为查询条件时,查到该数据会直接返回,不会继续扫表</li>
</ul>
</li>
<li>更新<ul>
<li>普通索引会直接将操作更新到 change buffer 中,然后结束</li>
<li>唯一索引需要判断数据是否冲突，不能使用change buffer</li>
</ul>
</li>
</ul>
<p>适合场景：</p>
<ul>
<li>普通索引适合<strong>读多写少</strong>的情况，尤其是在写完，立马就读的场景是不能使用的（原因是会增加changebuffer 的维护成本）</li>
<li>一般不建议使用唯一索引</li>
</ul>
<h3 id="什么是事务-其特性是什么"><a href="#什么是事务-其特性是什么" class="headerlink" title="什么是事务?其特性是什么?"></a>什么是事务?其特性是什么?</h3><p>事务是指是程序中一系列操作必须全部成功完成，有一个失败则全部失败。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/6d4384f30d148e586ee353b97e1f0fef.png" alt="6d4384f30d148e586ee353b97e1f0fef.png" style="zoom:50%;" />

<p>特性</p>
<ul>
<li><strong>「1.原子性（Atomicity）」</strong>：要么全部执行成功，要么全部不执行。</li>
<li><strong>「2.一致性（Consistency）」</strong>：事务前后数据的完整性必须保持一致。</li>
<li><strong>「3.隔离性（Isolation）」</strong>：隔离性是当多个事务同事触发时，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li>
<li><strong>「4.持久性（Durability）」</strong>：事务完成之后的改变是永久的。</li>
</ul>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别?"></a>事务的隔离级别?</h3><ul>
<li>1.<strong>「读提交」</strong>:即能够<strong>「读取到那些已经提交」</strong>的数据</li>
<li>2.<strong>「读未提交」</strong>:即能够<strong>「读取到没有被提交」</strong>的数据</li>
<li>3.<strong>「可重复读」</strong>:可重复读指的是在一个事务内，最开始读到的数据和事务结束前的<strong>「任意时刻读到的同一批数据都是一致的」</strong></li>
<li>4.<strong>「可串行化」</strong>:最高事务隔离级别，不管多少事务，都是<strong>「依次按序一个一个执行」</strong></li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/875a4a8184a2eccf33ca1176799d540a.png" alt="875a4a8184a2eccf33ca1176799d540a.png" style="zoom: 67%;" />

<ul>
<li><strong>「脏读」</strong><ul>
<li>脏读指的是<strong>「读到了其他事务未提交的数据」</strong>，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读</li>
</ul>
</li>
<li><strong>「不可重复读」</strong><ul>
<li>对比可重复读，不可重复读指的是在同一事务内，<strong>「不同的时刻读到的同一批数据可能是不一样的」</strong>。</li>
</ul>
</li>
<li><strong>「幻读」</strong><ul>
<li>幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现<strong>「好像刚刚的更改对于某些数据未起作用」</strong>，但其实是事务B刚插入进来的这就叫幻读</li>
</ul>
</li>
</ul>
<h3 id="binlog-是做什么的"><a href="#binlog-是做什么的" class="headerlink" title="binlog 是做什么的?"></a>binlog 是做什么的?</h3><p>binlog 是归档日志，属于 Server 层的日志，是一个二进制格式的文件，用于<strong>「记录用户对数据库更新的SQL语句信息」</strong>。</p>
<p>主要作用</p>
<ul>
<li>主从复制</li>
<li>数据恢复</li>
</ul>
<h3 id="undolog-是做什么的"><a href="#undolog-是做什么的" class="headerlink" title="undolog 是做什么的?"></a>undolog 是做什么的?</h3><p>undolog 是 InnoDB 存储引擎的日志，用于保证数据的原子性，<strong>「保存了事务发生之前的数据的一个版本，也就是说记录的是数据是修改之前的数据，可以用于回滚」</strong>，同时可以提供多版本并发控制下的读（MVCC）。</p>
<p>主要作用</p>
<ul>
<li>事务回滚</li>
<li>实现多版本控制(MVCC)</li>
</ul>
<h3 id="relaylog-是做什么的"><a href="#relaylog-是做什么的" class="headerlink" title="relaylog 是做什么的?"></a>relaylog 是做什么的?</h3><p>relaylog 是中继日志，<strong>「在主从同步的时候使用到」</strong>，它是一个中介临时的日志文件，用于存储从master节点同步过来的binlog日志内容。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/682ebc9c026cc8b81bc74ca0115f79df.png" alt="682ebc9c026cc8b81bc74ca0115f79df.png" style="zoom:67%;" />

<p>master 主节点的 binlog 传到 slave 从节点后，被写入 relay log 里，从节点的 slave sql 线程从 relaylog 里读取日志然后应用到 slave 从节点本地。从服务器 I/O 线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后 SQL 线程会读取 relay-log 日志的内容并应用到从服务器，从而<strong>「使从服务器和主服务器的数据保持一致」</strong>。</p>
<h3 id="redolog-是做什么的"><a href="#redolog-是做什么的" class="headerlink" title="redolog 是做什么的?"></a>redolog 是做什么的?</h3><p>redolog 是 <strong>「InnoDB 存储引擎所特有的一种日志」</strong>，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。</p>
<p>可以做<strong>「数据恢复并且提供 crash-safe 能力」</strong></p>
<p>当有增删改相关的操作时，会先记录到 Innodb 中，并修改缓存页中的数据，<strong>「等到 mysql 闲下来的时候才会真正的将 redolog 中的数据写入到磁盘当中」</strong>。</p>
<h3 id="redolog-是怎么记录日志的"><a href="#redolog-是怎么记录日志的" class="headerlink" title="redolog 是怎么记录日志的?"></a>redolog 是怎么记录日志的?</h3><img src="https://img-blog.csdnimg.cn/img_convert/9b9820761e6fc6d9b2644f70fea0c878.png" alt="9b9820761e6fc6d9b2644f70fea0c878.png" style="zoom:67%;" />

<p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么总共就可以记录4GB的操作。<strong>「从头开始写，写到末尾就又回到开头循环写」</strong>。</p>
<p>所以，如果数据写满了但是还没有来得及将数据真正的刷入磁盘当中，那么就会发生<strong>「内存抖动」</strong>现象，从肉眼的角度来观察会发现 mysql 会宕机一会儿，此时就是正在刷盘了。</p>
<h3 id="redolog-和-binlog-的区别是什么"><a href="#redolog-和-binlog-的区别是什么" class="headerlink" title="redolog 和 binlog 的区别是什么?"></a>redolog 和 binlog 的区别是什么?</h3><img src="https://img-blog.csdnimg.cn/img_convert/b83959086f28bb82d5dd174a12af8bdc.png" alt="b83959086f28bb82d5dd174a12af8bdc.png" style="zoom:50%;" />

<ul>
<li><strong>「redolog」</strong> 是 <strong>「Innodb」</strong> 独有的日志，而 <strong>「binlog」</strong> 是 <strong>「server」</strong> 层的，所有的存储引擎都有使用到</li>
<li><strong>「redolog」</strong> 记录了<strong>「具体的数值」</strong>，对某个页做了什么修改，<strong>「binlog」</strong> 记录的<strong>「操作内容」</strong></li>
<li><strong>「binlog」</strong> 大小达到上限或者 flush log <strong>「会生成一个新的文件」</strong>，而 <strong>「redolog」</strong> 有固定大小<strong>「只能循环利用」</strong></li>
<li><strong>「binlog 日志没有 crash-safe 的能力」</strong>，只能用于归档。而 redo log 有 crash-safe 能力。</li>
<li>binlog 是server 层，redolog 是存储层</li>
</ul>
<h3 id="说一说-mvcc-吧，有什么作用"><a href="#说一说-mvcc-吧，有什么作用" class="headerlink" title="说一说 mvcc 吧，有什么作用?"></a>说一说 mvcc 吧，有什么作用?</h3><p>MVCC:多版本并发控制，是现代数据库(包括 MySQL、Oracle、PostgreSQL 等)引擎实现中常用的处理读写冲突的手段，目的在于<strong>「提高数据库高并发场景下的吞吐性能」</strong>。</p>
<p>在 MVCC 协议下，每个读操作会看到一个一致性的快照，<strong>「这个快照是基于整个库的」</strong>，并且可以实现非阻塞的读，用于<strong>「支持读提交和可重复读隔离级别的实现」</strong>。</p>
<p>MVCC 允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务 ID，在同一个时间点，不同的事务看到的数据是不同的，这个修改的数据是<strong>「记录在 undolog 中」</strong>的。</p>
<h3 id="一条-Sql-语句查询一直慢会是什么原因"><a href="#一条-Sql-语句查询一直慢会是什么原因" class="headerlink" title="一条 Sql 语句查询一直慢会是什么原因?"></a>一条 Sql 语句查询一直慢会是什么原因?</h3><img src="https://img-blog.csdnimg.cn/img_convert/d52351ca45402fd46125dc2e59be0a76.png" alt="d52351ca45402fd46125dc2e59be0a76.png" style="zoom:50%;" />

<ul>
<li><strong>「1.没有用到索引」</strong><ul>
<li>比如函数导致的索引失效，或者本身就没有加索引</li>
</ul>
</li>
<li><strong>「2.表数据量太大」</strong><ul>
<li>考虑分库分表吧</li>
</ul>
</li>
<li><strong>「3.优化器选错了索引」</strong><ul>
<li><strong>「考虑使用」</strong> force index 强制走索引</li>
</ul>
</li>
</ul>
<h3 id="一条-Sql-语句查询偶尔慢会是什么原因"><a href="#一条-Sql-语句查询偶尔慢会是什么原因" class="headerlink" title="一条 Sql 语句查询偶尔慢会是什么原因?"></a>一条 Sql 语句查询偶尔慢会是什么原因?</h3><img src="https://img-blog.csdnimg.cn/img_convert/bd6876ff641aba17165df1c7ef249df5.png" alt="bd6876ff641aba17165df1c7ef249df5.png" style="zoom: 67%;" />

<ul>
<li><strong>「1. 数据库在刷新脏页」</strong><ul>
<li>比如 <strong>「redolog 写满了」</strong>，<strong>「内存不够用了」</strong>释放内存如果是脏页也需要刷，mysql <strong>「正常空闲状态刷脏页」</strong></li>
</ul>
</li>
<li><strong>「2. 没有拿到锁」</strong></li>
</ul>
<h3 id="Mysql-主从之间是怎么同步数据的"><a href="#Mysql-主从之间是怎么同步数据的" class="headerlink" title="Mysql 主从之间是怎么同步数据的?"></a>Mysql 主从之间是怎么同步数据的?</h3><ul>
<li>1.master 主库将此次更新的事件类型<strong>「写入到主库的 binlog 文件」</strong>中</li>
<li>2.master <strong>「创建 log dump 线程通知 slave」</strong> 需要更新数据</li>
<li>3.<strong>「slave」</strong> 向 master 节点发送请求，<strong>「将该 binlog 文件内容存到本地的 relaylog 中」</strong></li>
<li>4.<strong>「slave 开启 sql 线程」</strong>读取 relaylog 中的内容，<strong>「将其中的内容在本地重新执行一遍」</strong>，完成主从数据同步</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/fae385cd4a137a82e28b52c9eb9737a5.png" alt="fae385cd4a137a82e28b52c9eb9737a5.png" style="zoom: 67%;" />

<p><strong>「同步策略」</strong>：</p>
<ul>
<li>1.<strong>「全同步复制」</strong>：主库强制同步日志到从库，等全部从库执行完才返回客户端，性能差</li>
<li>2.<strong>「半同步复制」</strong>：主库收到至少一个从库确认就认为操作成功，从库写入日志成功返回ack确认</li>
</ul>
<h3 id="主从延迟要怎么解决"><a href="#主从延迟要怎么解决" class="headerlink" title="主从延迟要怎么解决?"></a>主从延迟要怎么解决?</h3><ul>
<li>1.MySQL 5.6 版本以后，提供了一种<strong>「并行复制」</strong>的方式，通过将 SQL 线程转换为多个 work 线程来进行重放</li>
<li>2.<strong>「提高机器配置」</strong>(王道)</li>
<li>3.在业务初期就选择合适的分库、分表策略，<strong>「避免单表单库过大」</strong>带来额外的复制压力</li>
<li>4.<strong>「避免长事务」</strong></li>
<li>5.<strong>「避免让数据库进行各种大量运算」</strong></li>
<li>6.对于一些对延迟很敏感的业务<strong>「直接使用主库读」</strong></li>
</ul>
<h3 id="删除表数据后表的大小却没有变动-这是为什么"><a href="#删除表数据后表的大小却没有变动-这是为什么" class="headerlink" title="删除表数据后表的大小却没有变动,这是为什么?"></a>删除表数据后表的大小却没有变动,这是为什么?</h3><p>在使用 delete 删除数据时，其实对应的数据行并不是真正的删除，是<strong>「逻辑删除」</strong>，InnoDB 仅仅是将其<strong>「标记成可复用的状态」</strong>，所以表空间不会变小</p>
<h3 id="为什么-VarChar-建议不要超过255"><a href="#为什么-VarChar-建议不要超过255" class="headerlink" title="为什么 VarChar 建议不要超过255?"></a>为什么 VarChar 建议不要超过255?</h3><img src="https://img-blog.csdnimg.cn/img_convert/e7172b78774dcb6d1679d262491d3a32.png" alt="e7172b78774dcb6d1679d262491d3a32.png" style="zoom:67%;" />

<p>innodb索引列最大长度不能超过767byte，等同于utf8mb4编码下，前缀索引列不能超过191，可以通过innodb_large_prefix参数修改+修改行格式来变大</p>
<h3 id="分布式式事务怎么实现"><a href="#分布式式事务怎么实现" class="headerlink" title="分布式式事务怎么实现?"></a>分布式式事务怎么实现?</h3><ul>
<li>1.<strong>「本地消息表」</strong></li>
<li>2.<strong>「消息事务」</strong></li>
<li>3.<strong>「二阶段提交」</strong></li>
<li>4.<strong>「三阶段提交」</strong></li>
<li>5.<strong>「TCC」</strong></li>
<li>6.<strong>「最大努力通知」</strong></li>
<li>7.<strong>「Seata 框架」</strong></li>
</ul>
<p><a href="https://blog.csdn.net/qq_43513205/article/details/114265756">七种分布式事务的解决方案，一次讲给你听</a></p>
<h3 id="Mysql-中有哪些锁"><a href="#Mysql-中有哪些锁" class="headerlink" title="Mysql 中有哪些锁?"></a>Mysql 中有哪些锁?</h3><p>以下并不全，主要理解下锁的意义即可</p>
<ul>
<li>基于锁的属性分类：共享锁、排他锁</li>
<li>基于锁的粒度分类：表锁、行锁、记录锁、间隙锁、临键锁</li>
<li>基于锁的状态分类：意向共享锁、意向排它锁、死锁</li>
</ul>
<h3 id="为什么不要使用长事务"><a href="#为什么不要使用长事务" class="headerlink" title="为什么不要使用长事务?"></a>为什么不要使用长事务?</h3><img src="https://img-blog.csdnimg.cn/img_convert/5cca8dadf562adaf140437cf95001d59.png" alt="5cca8dadf562adaf140437cf95001d59.png" style="zoom:67%;" />

<ul>
<li>1.并发情况下，数据库<strong>「连接池容易被撑爆」</strong></li>
<li>2.<strong>「容易造成大量的阻塞和锁超时」</strong><ul>
<li>长事务还占用锁资源，也可能拖垮整个库，</li>
</ul>
</li>
<li>3.执行时间长，容易造成<strong>「主从延迟」</strong></li>
<li>4.<strong>「回滚所需要的时间比较长」</strong><ul>
<li>事务越长整个时间段内的事务也就越多</li>
</ul>
</li>
<li>5.<strong>「undolog 日志越来越大」</strong><ul>
<li>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</li>
</ul>
</li>
</ul>
<h3 id="buffer-pool-是做什么的"><a href="#buffer-pool-是做什么的" class="headerlink" title="buffer pool 是做什么的?"></a>buffer pool 是做什么的?</h3><p>buffer pool 是一块内存区域，为了<strong>「提高数据库的性能」</strong>，当数据库操作数据的时候，把硬盘上的数据加载到 buffer pool，不直接和硬盘打交道，操作的是 buffer pool 里面的数据，数据库的增删改查都是在 buffer pool 上进行</p>
<p>buffer pool 里面缓存的数据内容也是一个个数据页</p>
<p>其中<strong>「有三大双向链表」</strong>:</p>
<ul>
<li><strong>「free 链表」</strong><ul>
<li>用于帮助我们找到空闲的缓存页</li>
</ul>
</li>
<li><strong>「flush 链表」</strong><ul>
<li>用于找到脏缓存页，也就是需要刷盘的缓存页</li>
</ul>
</li>
<li><strong>「lru 链表」</strong><ul>
<li>用来淘汰不常被访问的缓存页，分为热数据区和冷数据区，冷数据区主要存放那些不常被用到的数据</li>
</ul>
</li>
</ul>
<p>预读机制:</p>
<ul>
<li>Buffer Pool 有一项特技叫预读，存储引擎的接口在被 Server 层调用时，会在响应的同时进行预判，将下次可能用到的数据和索引加载到 Buffer Pool</li>
</ul>
<h2 id="35-说说你的-Sql-调优思路吧"><a href="#35-说说你的-Sql-调优思路吧" class="headerlink" title="35.说说你的 Sql 调优思路吧"></a>35.说说你的 Sql 调优思路吧</h2><img src="https://img-blog.csdnimg.cn/img_convert/e6d0dffc2b67df74c5ebc558dcb3e9ff.png" alt="e6d0dffc2b67df74c5ebc558dcb3e9ff.png" style="zoom:67%;" />

<ul>
<li>1.<strong>「表结构优化」</strong><ul>
<li>1.1拆分字段</li>
<li>1.2字段类型的选择</li>
<li>1.3字段类型大小的限制</li>
<li>1.4合理的增加冗余字段</li>
<li>1.5新建字段一定要有默认值</li>
</ul>
</li>
<li>2.<strong>「索引方面」</strong><ul>
<li>2.1索引字段的选择</li>
<li>2.2利用好mysql支持的索引下推，覆盖索引等功能</li>
<li>2.3唯一索引和普通索引的选择</li>
</ul>
</li>
<li>3.<strong>「查询语句方面」</strong><ul>
<li>3.1避免索引失效</li>
<li>3.2合理的书写where条件字段顺序</li>
<li>3.3小表驱动大表</li>
<li>3.4可以使用force index()防止优化器选错索引</li>
</ul>
</li>
<li>4.<strong>「分库分表」</strong></li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>go基础</title>
    <url>/2021/12/11/go%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>go的基础知识</p>
</blockquote>
<span id="more"></span>

<h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p><img src="https://gitee.com/Leo_Anna/image/raw/master/img//20210518174338.png" alt="image-20210518174338035"></p>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="使用mod进行包管理"><a href="#使用mod进行包管理" class="headerlink" title="使用mod进行包管理"></a>使用mod进行包管理</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> env -w GOPROXY=https:<span class="comment">//goproxy.cn,direct</span></span><br><span class="line">不使用代理的库</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> env -w GOPRIVATE=*.gitlab.com</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> env -w GO111MODULE=on</span><br></pre></td></tr></table></figure>

<p><strong>解决私有库 https 依赖无法get或者mod</strong></p>
<p>在Go 1.14中增加了新的环境变量，用于指定哪些域名下的仓库不去校验CA证书。</p>
<p>使用方式同 GOPRIVATE 类似 <em><strong>*go env -w GOINSECURE=private.repo.com*</strong></em> </p>
<ul>
<li>go env -w GOINSECURE=gitlab.mogujie.org</li>
<li>go env -w GOPRIVATE=gitlab.mogujie.org</li>
</ul>
<p><strong>替换包版本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go get github.com/golang/image@master</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go mod edit -replace=old[@v]=new[@v]</span><br></pre></td></tr></table></figure>



<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><ul>
<li>git pull origin master –allow-unrelated-histories 强制合并</li>
<li>git branch -v 查看本地所有分支</li>
<li>git status 查看当前状态 </li>
<li>git commit 提交 </li>
<li>git branch -a 查看所有的分支</li>
<li>git commit -am “init” 提交并且加注释 </li>
<li>git remote add origin <a href="mailto:&#x67;&#105;&#x74;&#64;&#x31;&#x39;&#50;&#x2e;&#49;&#54;&#56;&#46;&#x31;&#46;&#x31;&#49;&#57;">&#x67;&#105;&#x74;&#64;&#x31;&#x39;&#50;&#x2e;&#49;&#54;&#56;&#46;&#x31;&#46;&#x31;&#49;&#57;</a>:ndshow</li>
<li>git push origin master 将文件给推到服务器上 </li>
<li>git remote show origin 显示远程库origin里的资源 </li>
<li>git checkout dev 切换到本地dev分支</li>
<li>git remote show 查看远程库</li>
<li>git rm 文件名(包括路径) 从git中删除指定文件q</li>
<li>保存密码<ul>
<li>echo https://{username}:{password}@github.com &gt;  /.git-credentials </li>
<li>git config –global credential.helper store</li>
</ul>
</li>
</ul>
<h1 id="语法学习"><a href="#语法学习" class="headerlink" title="语法学习"></a>语法学习</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量占用"><a href="#变量占用" class="headerlink" title="变量占用"></a>变量占用</h3><p>变量名本质是使用方便的占位符，用于引用计算机内存地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   s1 := <span class="string">&#x27;b&#x27;</span></span><br><span class="line">   s2 := <span class="string">&quot;b&quot;</span></span><br><span class="line">   s3 :=<span class="literal">true</span></span><br><span class="line">   s4 := <span class="number">100</span></span><br><span class="line">   s5 := &amp;s2</span><br><span class="line">   fmt.Printf(<span class="string">&quot;字符型（ascll）：%d\n&quot;</span>,unsafe.Sizeof(s1))</span><br><span class="line">   fmt.Printf(<span class="string">&quot;字符串型：%d\n&quot;</span>,unsafe.Sizeof(s2))</span><br><span class="line">   fmt.Printf(<span class="string">&quot;布尔型：%d\n&quot;</span>,unsafe.Sizeof(s3))</span><br><span class="line">   fmt.Printf(<span class="string">&quot;整数型：%d\n&quot;</span>,unsafe.Sizeof(s4))</span><br><span class="line">   fmt.Printf(<span class="string">&quot;指针型：%d\n&quot;</span>,unsafe.Sizeof(s5))</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;</span><br><span class="line">字符型（ascll）：<span class="number">4</span></span><br><span class="line">字符串型：<span class="number">16</span></span><br><span class="line">布尔型：<span class="number">1</span></span><br><span class="line">整数型：<span class="number">8</span></span><br><span class="line">指针型：<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>字符和字符串的大小</li>
<li>指针型大小</li>
<li>上面的大小与数据量无关，<strong>与数据类型有关</strong></li>
<li>go没有字符类型变量，字符型其实就是ascll</li>
</ul>
<h3 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h3><p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p>
<p>零值是：</p>
<ul>
<li>数值类型为 <code>0</code>，</li>
<li>布尔类型为 <code>false</code>，</li>
<li>字符串为 <code>&quot;&quot;</code>（空字符串）</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>使用const </p>
<p>常量不能用:=声明</p>
<p>const Pi =3.14</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>go只有一种循环结构</p>
<p><strong>用法：</strong></p>
<ul>
<li><p>for i := 0; i &lt; 10; i++ {</p>
<pre><code>sum += i
 &#125;
</code></pre>
</li>
<li><p>类while</p>
<p>for sum &lt; 1000 {</p>
<pre><code>    sum += sum
&#125;
</code></pre>
</li>
</ul>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行<strong>一个简单</strong>的语句。</p>
<p>该语句声明的变量作用域仅在 <code>if</code> 之内。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">		<span class="keyword">return</span> v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用。</p>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句。 除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// freebsd, openbsd,</span></span><br><span class="line">		<span class="comment">// plan9, windows...</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>defer 语句会将函数推迟到外层函数返回之后执行。</p>
<p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p>
<p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>技术上也是引用类型，包含指向底层数据的指针和长度</p>
</li>
<li><p>支持切片</p>
</li>
<li><p>使用utf8编码</p>
</li>
<li><p>原声输出字符串，可以用``,反引号</p>
</li>
</ul>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><ul>
<li>go没有单独的字符类型，用byte保存，在go中，字符的本质是整数</li>
<li>如何保存的字符码值大于255，可以考虑使用int类型保存</li>
<li>go 字符使用utf编码</li>
<li></li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doubleNum</span><span class="params">(x [10] <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b [] <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(x);i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> (x[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">			b=<span class="built_in">append</span>(b,x[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：参数为数组的时候，注意要与初始化的类型一样</p>
<h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>go语言引用类型有：切片、映射、通道、接口和函数（字符串咋技术上也是引用类型），每个引用类型都会创建标头，标头值指向底层数据结构指针，还包括一组独特的字段用于管理底层数据结构，当复制此类变量的时候，实际上就是在<strong>共享底层数据结构</strong>。</p>
<p><img src="https://gitee.com/leo_anna/image/raw/master/img//20211004112922.png" alt="image-20211004112922111"></p>
<p>　值类型：基本数据类型int系列，float系列，bool，string，数组和结构体 struct</p>
<p>　引用类型：指针，slice切片，map，管道chan，interface等都是引用数据类型</p>
<h2 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h2><ul>
<li>都是分配内存的内置函数</li>
<li>new主要用来分配值类型，返回的是指针类型</li>
<li>make主要用来分配引用类型</li>
<li></li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>数组范围大小固定且内存地址连续，不能进行添加范围外的元素</strong>，分片可以</p>
<p>未初始化的元素默认为0</p>
<p>变量名本质是使用方便的占位符，用于引用计算机内存地址。</p>
<h3 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h3><p>数组声明一定要指定长度，且不可改变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name [20] int </span><br><span class="line">name :=[5] int &#123;10,20,30,40,50&#125;</span><br><span class="line">name :=[...] int &#123;10,20,30,40,50&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组传参"><a href="#数组传参" class="headerlink" title="数组传参"></a>数组传参</h3><ul>
<li><p>传的数组长度必须一致</p>
</li>
<li><p>函数传数组是开销很大的操作，且<strong>总是以值的方式传递</strong>的，无论数组有多长，都会全部传递过去，所以开发中尽量用切片传参</p>
</li>
</ul>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><ul>
<li> 切片是一种数据结构，和数组不一样！！！</li>
<li> 切片函数传参也是复制了值，但是由于切片实际上尺寸很小，只有24个字节（三个字段各8个字节），不会复制底层数据，效率很高</li>
<li> 内部实现： 切片是对底层数组进行了抽象，并提供相关的操作方法，切片有三个字段，分别为：指向底层数组的指针、切片长度（可以访问的个数）、切片容量（允许增长的个数）</li>
</ul>
<p><img src="https://gitee.com/leo_anna/image/raw/master/img//20210324160341.png" alt="image-20210324160239852"></p>
<h3 id="创建切片"><a href="#创建切片" class="headerlink" title="创建切片"></a>创建切片</h3><p><strong>在[]中指定的大小，就不是切片，而是数组了</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice :=<span class="built_in">make</span> ([] <span class="keyword">string</span>,<span class="number">5</span>) <span class="comment">//容量和长度都是5</span></span><br><span class="line">slice :=<span class="built_in">make</span> ([] <span class="keyword">string</span>,<span class="number">3</span>,<span class="number">5</span>)  <span class="comment">//长度3，容量5</span></span><br><span class="line">slice :=[] <span class="keyword">string</span>&#123;<span class="string">&quot;Green&quot;</span>,<span class="string">&quot;Red&quot;</span>,<span class="string">&quot;Blue&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> <span class="comment">//创建nil切片</span></span><br><span class="line"></span><br><span class="line">newSlice:=slice[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">//使用切片创造切片</span></span><br></pre></td></tr></table></figure>

<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><ul>
<li>用于增加切片的访问个数，有可能增加容量，也可以不增加</li>
<li>下面的代码#3 就会增加newSlice的长度同时修改slice里面的40为50</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice :=[] <span class="keyword">int</span> &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;</span><br><span class="line">newSlice :=slice[<span class="number">1</span>:<span class="number">3</span>]<span class="comment">//长度为2（3-1），容量为3（4-1）</span></span><br><span class="line">newSlice=<span class="built_in">append</span>(newSlice,<span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>上面是切片容量在底层数组的范围内的情况，如果使用了append，但是超过了底层数组的长度，那么就是重新创建一个底层数组，且容量是原来的2倍（1000之内会成倍增加）</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p><code>*</code> 操作符表示指针指向的底层值。</p>
<p>指针变量里面保存的是内存地址，可以通过&amp;读取操作数的内存地址</p>
<p>例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i  #把内存地址赋于指针变量</span><br><span class="line">fmt.Println(*p)  #通过*，引用内存地址的值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例理解</p>
<h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> max =<span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	a := []<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> ptr [max]*<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; max;i++&#123;</span><br><span class="line">		ptr[i] =&amp;a[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i :=<span class="number">0</span>; i&lt;max;i++&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;a[%d]=%d\n&quot;</span>,i,*ptr[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">4</span></span><br><span class="line">a[<span class="number">1</span>]=<span class="number">5</span></span><br><span class="line">a[<span class="number">2</span>]=<span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> b **<span class="keyword">int</span></span><br><span class="line">	c := <span class="number">5</span></span><br><span class="line">	a = &amp;c</span><br><span class="line">	b = &amp;a</span><br><span class="line">	fmt.Println(*a)</span><br><span class="line">	fmt.Println(*b)</span><br><span class="line">	fmt.Println(**b)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0xc000016040</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	*x++</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line">	a =&amp;num</span><br><span class="line">	num =<span class="number">2</span></span><br><span class="line">	test(a)</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>



<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="结构体声明和创建"><a href="#结构体声明和创建" class="headerlink" title="结构体声明和创建"></a>结构体声明和创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Books struct &#123;</span><br><span class="line">   title string</span><br><span class="line">   author string</span><br><span class="line">   subject string</span><br><span class="line">   book_id int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">   var mysqlbook Books</span><br><span class="line">   var linuxbook Books</span><br><span class="line">   mysqlbook=Books&#123;&quot;mysqlbook&quot;, &quot;www.runoob.com&quot;, &quot;Go 语言教程&quot;, 6495407&#125;</span><br><span class="line"></span><br><span class="line">   linuxbook.title=&quot;linuxbook&quot;</span><br><span class="line">   linuxbook.author=&quot;www.runoob.com&quot;</span><br><span class="line">   linuxbook.subject=&quot;Go 语言教程&quot;</span><br><span class="line">   linuxbook.book_id=6495407</span><br><span class="line"></span><br><span class="line">   fmt.Println(mysqlbook)</span><br><span class="line">   fmt.Println(linuxbook)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;</span><br><span class="line">&#123;mysqlbook www.runoob.com Go 语言教程 6495407&#125;</span><br><span class="line">&#123;linuxbook www.runoob.com Go 语言教程 6495407&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="new和var初始化区别"><a href="#new和var初始化区别" class="headerlink" title="new和var初始化区别"></a>new和var初始化区别</h3><p><strong>new 初始化，返回的结构体指针</strong></p>
<p><strong>var 初始化，返回的就是结构体</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="keyword">int</span></span><br><span class="line">	Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	a:=<span class="built_in">new</span>(ListNode)</span><br><span class="line">	<span class="keyword">var</span> b ListNode</span><br><span class="line">	c:=ListNode&#123;&#125;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&amp;&#123;<span class="number">0</span> &lt;<span class="literal">nil</span>&gt;&#125; <span class="comment">//new返回的是指针</span></span><br><span class="line">&#123;<span class="number">0</span> &lt;<span class="literal">nil</span>&gt;&#125;  <span class="comment">//</span></span><br><span class="line">&#123;<span class="number">0</span> &lt;<span class="literal">nil</span>&gt;&#125;  <span class="comment">//</span></span><br></pre></td></tr></table></figure>







<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 没有类。不过你可以为结构体类型定义方法。</p>
<p>方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</p>
<p>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p>
<p><strong>注意：记住：方法只是个带接收者参数的函数。</strong></p>
<h3 id="方法和函数"><a href="#方法和函数" class="headerlink" title="方法和函数"></a>方法和函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X,Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver *Vertex)</span> <span class="title">add</span><span class="params">(num <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	receiver.X = receiver.X +num</span><br><span class="line">	receiver.Y = receiver.Y +num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Multiply</span><span class="params">(ver *Vertex)</span></span>  &#123;</span><br><span class="line">	ver.X = ver.X * ver.Y</span><br><span class="line">	ver.Y = ver.X * ver.Y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	ver := Vertex&#123;<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">	ver.add(<span class="number">2</span>)</span><br><span class="line">	fmt.Println(ver)</span><br><span class="line">	Multiply(&amp;ver)</span><br><span class="line">	fmt.Println(ver)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&#123;<span class="number">5</span> <span class="number">6</span>&#125;</span><br><span class="line">&#123;<span class="number">30</span> <span class="number">180</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法和指针"><a href="#方法和指针" class="headerlink" title="方法和指针"></a>方法和指针</h3><ul>
<li>方法接受者为指针时，调用时，接受者既可以为指针又可以为值，而且可以全局修改接受者指向的值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	v.X=<span class="number">30</span></span><br><span class="line">	v.Y=<span class="number">40</span></span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	v:=Vertex&#123;<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">	fmt.Println(v.X,v.Y)</span><br><span class="line">	vv:=&amp;v <span class="comment">//转为指针</span></span><br><span class="line">	fmt.Println(vv.Abs())</span><br><span class="line">	fmt.Println(vv.X,vv.Y)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">30</span> <span class="number">40</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">30</span> <span class="number">40</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>方法接受者为值时的值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	v.X=<span class="number">30</span></span><br><span class="line">	v.Y=<span class="number">40</span></span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	v:=Vertex&#123;<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">	fmt.Println(v.X,v.Y)</span><br><span class="line">	vv:=&amp;v <span class="comment">//转为指针</span></span><br><span class="line">	fmt.Println(vv.Abs())</span><br><span class="line">	fmt.Println(vv.X,vv.Y)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>



<h2 id="接口-（多态）"><a href="#接口-（多态）" class="headerlink" title="接口 （多态）"></a>接口 （多态）</h2><p><strong>接口类型</strong> 是由一组方法签名定义的集合。</p>
<p>接口类型的变量可以保存任何实现了这些方法的值。</p>
<p>调用接口时，会自动执行其底层类型的同名方法，</p>
<p>实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> V <span class="keyword">interface</span> &#123;</span><br><span class="line">	Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	v.X=<span class="number">30</span></span><br><span class="line">	v.Y=<span class="number">40</span></span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex2)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v.X</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	v:=Vertex&#123;<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">	v1:=Vertex2&#123;<span class="number">10</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> i V</span><br><span class="line">	i=&amp;v</span><br><span class="line">	fmt.Println(i.Abs())</span><br><span class="line">	i=&amp;v1</span><br><span class="line">	fmt.Println(i.Abs())</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>空接口可以接受任意类型，在json或者未知类型分析中起到重要作用，而断言可以进行空接口类型确定或者接口类型判断</p>
<p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x.(T) <span class="comment">// 判断x的类型是否是T，其中x必须是接口值。</span></span><br><span class="line"></span><br><span class="line">t := x.(T) <span class="comment">// 不安全的type assertion，如果断言失败，会报panic</span></span><br><span class="line"></span><br><span class="line">t,ok : = x.(T) <span class="comment">// 安全的type assertion，即使断言失败，也可以根据ok值来做处理，而不会出现panic</span></span><br></pre></td></tr></table></figure>





<h2 id="切片-1"><a href="#切片-1" class="headerlink" title="切片"></a>切片</h2><p>初始化有以下几种，其实就是数组初始化的方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>) </span><br><span class="line"><span class="keyword">var</span> a [] <span class="keyword">int</span> =<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>) </span><br><span class="line"><span class="keyword">var</span> a [选填] <span class="keyword">int</span></span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>len()</li>
<li>Cap()最大长度，也就是数组容量，如果是make初始化或者用[number]的形式声明数组的容量就等于最大长度，否则等于len()</li>
<li>Copy(a,b) 复制</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	a := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;</span><br><span class="line">	c:=a[<span class="number">0</span>:]</span><br><span class="line">	d:=c[<span class="number">0</span>:]</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	d[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span>] #a</span><br><span class="line">[<span class="number">100</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span>] #a</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	a := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;</span><br><span class="line">	c:=a[<span class="number">0</span>:]</span><br><span class="line">	c=<span class="built_in">append</span>(c,<span class="number">101</span>)</span><br><span class="line">	c[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span>] #a</span><br><span class="line">[<span class="number">100</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">101</span>] #c</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p>
<p>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p><strong>key，value存储</strong></p>
<p>最通俗的话说Map是一种通过key来获取value的一个数据结构，其底层存储方式为数组，在存储时key不能重复，当key重复时，value进行覆盖，我们通过key进行hash运算（可以简单理解为把key转化为一个整形数字）然后对数组的长度取余，得到key存储在数组的哪个下标位置，最后将key和value组装为一个结构体，放入数组下标处，看下图：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">length = <span class="built_in">len</span>(array) = <span class="number">4</span></span><br><span class="line">hashkey1 = hash(xiaoming) = <span class="number">4</span></span><br><span class="line">index1  = hashkey1% length= <span class="number">0</span></span><br><span class="line">hashkey2 = hash(xiaoli) = <span class="number">6</span></span><br><span class="line">index2  = hashkey2% length= <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/leo_anna/image/raw/master/img//20211026203833.png" alt="img"></p>
<h3 id="定义-Map"><a href="#定义-Map" class="headerlink" title="定义 Map"></a>定义 Map</h3><p>可以使用内建函数 make 也可以使用 map 关键字来定义 Map:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 声明变量，默认 map 是 nil */</span><br><span class="line">var map_variable map[key_data_type]value_data_type</span><br><span class="line">/* 使用 make 函数 */</span><br><span class="line">map_variable = make(map[key_data_type]value_data_type)</span><br><span class="line">或者</span><br><span class="line">var map_variable map[key_data_type]value_data_type</span><br><span class="line">map_variable := map[key_data_type]value_data_type&#123;&#125;</span><br><span class="line">或者</span><br><span class="line">map_variable := map[key_data_type]value_data_type&#123;&#125;</span><br><span class="line">或者</span><br><span class="line">map_variable := make(map[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure>

<p>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</p>
<p><code>make</code> 函数会返回给定类型的映射，并将其初始化备用。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>作用：外部<strong>持续</strong>引用函数内部变量</p>
<p>慎用，闭包会一直存在于内存中，不会释放</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	sum := <span class="number">12</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		sum +=<span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x:=adder()</span><br><span class="line">	fmt.Println(x(<span class="number">1</span>))</span><br><span class="line">	fmt.Println(x(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>go语言没有集合，但是可以通过map+空结构体来实现类似的数据结构，如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">set= <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">set [<span class="number">1</span>] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure>





<p>因为空结构体a</p>
<h2 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h2><ul>
<li>_ “github…” 的作用是可以调用包却不使用，并初始化包，调用包内部的init函数</li>
</ul>
<h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>并发和并行</li>
</ul>
<p><img src="https://gitee.com/leo_anna/image/raw/master/img//20210819110221.png" alt="image-20210819110221303"></p>
<ul>
<li>协程和线程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。</span><br><span class="line">线程：一个线程上可以跑多个协程，协程是轻量级的线程。</span><br></pre></td></tr></table></figure>

<ul>
<li>goroutine 奉行通过通信来共享内存，而不是共享内存来通信。</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>sync.Waitgroup，等待进程结束和进程计数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line">        <span class="keyword">go</span> hello(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>runtime.Gosched()</p>
</li>
<li><p>runtime.Goexit()</p>
</li>
<li><p>sync.Mutex  加锁</p>
<p>for i := 0; i &lt; 5000; i++ {</p>
<pre><code>    lock.Lock() // 加锁
    x = x + 1
    lock.Unlock() // 解锁
&#125;
</code></pre>
</li>
</ul>
<h3 id="channel-通道"><a href="#channel-通道" class="headerlink" title="channel 通道"></a>channel 通道</h3><p>协程通信</p>
<p><strong>创建和使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) 无缓存</span><br><span class="line">ch4 :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) 有缓存</span><br><span class="line">ch&lt;<span class="number">-10</span></span><br><span class="line">data := -&lt;ch</span><br></pre></td></tr></table></figure>

<p><strong>通信方式</strong>：</p>
<ul>
<li><p>无缓冲通道</p>
<p><img src="http://www.topgoer.com/static/7.1/3.png" alt="img"></p>
<ul>
<li>无缓冲的通道只有在有人接收值的时候才能发送值,必须有接收者，否者会一直卡住，产生死锁</li>
</ul>
</li>
<li><p>有缓冲通道</p>
<p><img src="http://www.topgoer.com/static/7.1/4.png" alt="img"></p>
<ul>
<li><p>循环取值有两种方式：</p>
<p>等待通道关闭后，读取数据</p>
<p>一直读取通道数据直至通道关闭</p>
</li>
</ul>
</li>
<li><p>单向通道</p>
</li>
</ul>
<p>close:</p>
<ul>
<li>可以通过内置的close()函数关闭channel（如果你的管道不往里存值或者取值的时候一定记得关闭管道）</li>
</ul>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>Go 支持在一个平台下生成另一个平台可执行程序的交叉编译功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、Mac下编译Linux, Windows平台的<span class="number">64</span>位可执行程序：</span><br><span class="line"></span><br><span class="line">　$ CGO_ENABLED=<span class="number">0</span> GOOS=linux GOARCH=amd64 <span class="keyword">go</span> build test.<span class="keyword">go</span></span><br><span class="line">　$ CGO_ENABLED=<span class="number">0</span> GOOS=windows GOARCH=amd64 <span class="keyword">go</span> build test.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、Linux下编译Mac, Windows平台的<span class="number">64</span>位可执行程序：</span><br><span class="line"> $ CGO_ENABLED=<span class="number">0</span> GOOS=darwin GOARCH=amd64 <span class="keyword">go</span> build test.<span class="keyword">go</span></span><br><span class="line"> $ CGO_ENABLED=<span class="number">0</span> GOOS=windows GOARCH=amd64 <span class="keyword">go</span> build test.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、Windows下编译Mac, Linux平台的<span class="number">64</span>位可执行程序：</span><br><span class="line"> $ SET CGO_ENABLED=<span class="number">0</span>SET GOOS=darwin3 SET GOARCH=amd64 <span class="keyword">go</span> build test.<span class="keyword">go</span></span><br><span class="line"> $ SET CGO_ENABLED=<span class="number">0</span> SET GOOS=linux SET GOARCH=amd64 <span class="keyword">go</span> build test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>





<h2 id="mysql增删改查"><a href="#mysql增删改查" class="headerlink" title="mysql增删改查"></a>mysql增删改查</h2><ul>
<li><p>引入mysql包，在项目文件界面，执行go get github.com/go-sql-driver/mysql</p>
</li>
<li><p>数据库连接 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;user:password@tcp(localhost:5555)/dbname?charset=utf8&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>插入操作 insert</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stmt, err := db.Prepare(<span class="string">`INSERT user (user_name,user_age,user_sex) values (?,?,?)`</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">res, err := stmt.Exec(<span class="string">&quot;tony&quot;</span>, <span class="number">20</span>, <span class="number">1</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">id, err := res.LastInsertId()</span><br><span class="line">checkErr(err)</span><br><span class="line">fmt.Println(id)</span><br></pre></td></tr></table></figure>

<p>这里使用结构化操作，不推荐使用直接拼接sql语句的方法</p>
</li>
<li><p>查询操作 select</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rows, err := db.Query(<span class="string">&quot;SELECT * FROM user&quot;</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">	<span class="keyword">var</span> userId <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> userName <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> userAge <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> userSex <span class="keyword">int</span></span><br><span class="line">	rows.Columns()</span><br><span class="line">	err = rows.Scan(&amp;userId, &amp;userName, &amp;userAge, &amp;userSex)</span><br><span class="line">	checkErr(err)</span><br><span class="line">	fmt.Println(userId)</span><br><span class="line">	fmt.Println(userName)</span><br><span class="line">	fmt.Println(userAge)</span><br><span class="line">	fmt.Println(userSex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里查询的方式使用声明4个独立变量userId、userName、userAge、userSex来保存查询出来的每一行的值。在实际开发中通常会封装数据库的操作，对这样的查询通常会考虑返回字典类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造scanArgs、values两个数组，scanArgs的每个值指向values相应值的地址</span></span><br><span class="line">columns, _ := rows.Columns()</span><br><span class="line">scanArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</span><br><span class="line">values := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> values &#123;</span><br><span class="line">	scanArgs[i] = &amp;values[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">	<span class="comment">//将行数据保存到record字典</span></span><br><span class="line">	err = rows.Scan(scanArgs...)</span><br><span class="line">	record := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">for</span> i, col := <span class="keyword">range</span> values &#123;</span><br><span class="line">		<span class="keyword">if</span> col != <span class="literal">nil</span> &#123;</span><br><span class="line">			record[columns[i]] = <span class="keyword">string</span>(col.([]<span class="keyword">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(record)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改操作 update</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stmt, err := db.Prepare(<span class="string">`UPDATE user SET user_age=?,user_sex=? WHERE user_id=?`</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">res, err := stmt.Exec(<span class="number">21</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">num, err := res.RowsAffected()</span><br><span class="line">checkErr(err)</span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure>

<ul>
<li> 删除操作 delete</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stmt, err := db.Prepare(<span class="string">`DELETE FROM user WHERE user_id=?`</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">res, err := stmt.Exec(<span class="number">1</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">num, err := res.RowsAffected()</span><br><span class="line">checkErr(err)</span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure>

<p>修改和删除操作都比较简单，同插入数据类似，只是使用RowsAffected来获取影响的数据行数。</p>
<ul>
<li><p>checkErr</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkErr</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">args := os.Args[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> args == <span class="literal">nil</span> || <span class="built_in">len</span>(args) &lt; <span class="number">5</span> &#123;</span><br><span class="line">   Usage() #解析函数</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tid,_ := strconv.Atoi(args[<span class="number">0</span>]) </span><br><span class="line"><span class="keyword">string</span> ：= args[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>strconv.Atoi 转化为整数</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>用defer、panic和recover来处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	GO()</span><br><span class="line">	PHP()</span><br><span class="line">	PYTHON()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Go语言追求简洁优雅，所以，Go语言不支持传统的 try…catch…finally 这种异常，因为Go语言的设计者们认为，将异常与控制结构混在一起会很容易使得代码变得混乱。因为开发者很容易滥用异常，甚至一个小小的错误都抛出一个异常。在Go语言中，使用多值返回来返回错误。不要用异常代替错误，更不要用来控制流程。在极个别的情况下，也就是说，遇到真正的异常的情况下（比如除数为0了）。才使用Go中引入的Exception处理：defer, panic, recover。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Go没有异常机制，但有panic/recover模式来处理错误</span></span><br><span class="line"><span class="comment">//Panic可以在任何地方引发，但recover只有在defer调用的函数中有效</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GO</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是GO，现在没有发生异常，我是正常执行的。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PHP</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;终于捕获到了panic产生的异常：&quot;</span>, err) <span class="comment">// 这里的err其实就是panic传入的内容</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;我是defer里的匿名函数，我捕获到panic的异常了，我要recover，恢复过来了。&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// panic一般会导致程序挂掉（除非recover）  然后Go运行时会打印出调用栈</span></span><br><span class="line">	<span class="comment">//但是，关键的一点是，即使函数执行的时候panic了，函数不往下走了，运行时并不是立刻向上传递panic，而是到defer那，等defer的东西都跑完了，panic再向上传递。所以这时候 defer 有点类似 try-catch-finally 中的 finally。panic就是这么简单。抛出个真正意义上的异常。</span></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;我是PHP,我要抛出一个异常了，等下defer会通过recover捕获这个异常，然后正常处理，使后续程序正常运行。&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是PHP里panic后面要打印出的内容。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PYTHON</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是PYTHON，没有defer来recover捕获panic的异常，我是不会被正常执行的。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">我是GO，现在没有发生异常，我是正常执行的。</span><br><span class="line">终于捕获到了<span class="built_in">panic</span>产生的异常： 我是PHP,我要抛出一个异常了，等下<span class="keyword">defer</span>会通过<span class="built_in">recover</span>捕获这个异常，然后正常处理，使后续程序正常运行。</span><br><span class="line">我是<span class="keyword">defer</span>里的匿名函数，我捕获到<span class="built_in">panic</span>的异常了，我要<span class="built_in">recover</span>，恢复过来了。</span><br><span class="line">我是PYTHON，没有<span class="keyword">defer</span>来<span class="built_in">recover</span>捕获<span class="built_in">panic</span>的异常，我是不会被正常执行的。</span><br></pre></td></tr></table></figure>





<h1 id="Gin"><a href="#Gin" class="headerlink" title="Gin"></a>Gin</h1><h2 id="模型绑定和验证"><a href="#模型绑定和验证" class="headerlink" title="模型绑定和验证"></a>模型绑定和验证</h2><p>两种绑定方式</p>
<ul>
<li>Must bind  如果存在绑定错误，请求将被以下指令中止 <code>c.AbortWithError(400, err).SetType(ErrorTypeBind)</code></li>
<li>Should bind  如果存在绑定错误，则返回错误，开发人员可以正确处理请求和错误。</li>
</ul>
<h3 id="binding-quot-required-quot"><a href="#binding-quot-required-quot" class="headerlink" title="binding:&quot;required&quot;"></a><code>binding:&quot;required&quot;</code></h3><p>结构体字段修饰，并且在绑定时该字段的值为空，那么将返回一个错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定为json</span></span><br><span class="line"><span class="keyword">type</span> Login <span class="keyword">struct</span> &#123;</span><br><span class="line">	User     <span class="keyword">string</span> <span class="string">`form:&quot;user&quot; json:&quot;user&quot; xml:&quot;user&quot;  binding:&quot;required&quot;`</span></span><br><span class="line">	Password <span class="keyword">string</span> <span class="string">`form:&quot;password&quot; json:&quot;password&quot; xml:&quot;password&quot; binding:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Example for binding JSON (&#123;&quot;user&quot;: &quot;manu&quot;, &quot;password&quot;: &quot;123&quot;&#125;)</span></span><br><span class="line">	router.POST(<span class="string">&quot;/loginJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> json Login</span><br><span class="line">		<span class="keyword">if</span> err := c.ShouldBindJSON(&amp;json); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> json.User != <span class="string">&quot;manu&quot;</span> || json.Password != <span class="string">&quot;123&quot;</span> &#123;</span><br><span class="line">			c.JSON(http.StatusUnauthorized, gin.H&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;unauthorized&quot;</span>&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;you are logged in&quot;</span>&#125;)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="gin-H"><a href="#gin-H" class="headerlink" title="gin.H"></a>gin.H</h2><p>gin.H{} 等价于 map[string]interface{}{“”:””}</p>
<p>简化生成json的方式</p>
<h2 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h2><h2 id="next-、abort-、set"><a href="#next-、abort-、set" class="headerlink" title="next()、abort()、set()"></a>next()、abort()、set()</h2><ul>
<li>next() ，中间件执行会有洋葱效果，会暂时挂起当前函数，继续执行上层下面的，都执行完了，再回来执行剩下的</li>
<li>abort(),可以阻止挂起状态，直接截断后面的执行</li>
<li>set(),和Get一起使用，写入和获取上下文</li>
</ul>
<h2 id="gorm使用"><a href="#gorm使用" class="headerlink" title="gorm使用"></a>gorm使用</h2><h1 id="开发组件"><a href="#开发组件" class="headerlink" title="开发组件"></a>开发组件</h1><p>鉴权：jwt</p>
<p>数据库管理：gorm</p>
<p>配置文件管理：viper</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go基础</tag>
      </tags>
  </entry>
  <entry>
    <title>redolog和binlog 刷盘参数</title>
    <url>/2021/12/28/redolog%E5%92%8Cbinlog%20%E5%88%B7%E7%9B%98%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>涉及参数（都是事务提交后的动作参数）：</p>
<p>redolog：innodb_flush_log_at_trx_commit</p>
<p>binlog ：sync_binlog  binlog_group_commit_sync_delay  binlog_group_commit_sync_no_delay_count</p>
<p>主要分几个维度来分析和理解</p>
<span id="more"></span>

<h2 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h2><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>未提交前，写入binlog cache，提交后，写入file cache（简称write），然后根据sync_cache参数配置fsync到磁盘的时机</p>
<h3 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h3><p>未提交前，写入log buffer，提交后，写入file cache（简称write），，根据redolog：innodb_flush_log_at_trx_commit参数配置fsync到磁盘的时机</p>
<h3 id="binlog-cache和log-buffer区别"><a href="#binlog-cache和log-buffer区别" class="headerlink" title="binlog cache和log buffer区别"></a>binlog cache和log buffer区别</h3><p>binlog cache 是写binlog线程内存，是系统分配的和mysql进程内存无关</p>
<p>log buffer  是使用的mysql进程占有的内存</p>
<h3 id="未提交事务的redolog刷盘场景"><a href="#未提交事务的redolog刷盘场景" class="headerlink" title="未提交事务的redolog刷盘场景"></a>未提交事务的redolog刷盘场景</h3><ul>
<li><p>后台线程每秒轮询，把logbuffer里面中的日志写到file cache，然后调用fsync刷盘</p>
</li>
<li><p>redlog buffer 占用空间为buffer pool一半的空间的时候，会把日志写入file cache中不刷盘</p>
</li>
<li><p>并行的事务提交，且redolog：innodb_flush_log_at_trx_commit参数为1，则会写入file cache中并调用fsync刷盘</p>
</li>
</ul>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>binlog sync_binlog</p>
<ul>
<li>sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；</li>
<li>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</li>
<li>sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<p>redolog：innodb_flush_log_at_trx_commit</p>
<ul>
<li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li>
<li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li>
<li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li>
</ul>
<h3 id="“双1”配置"><a href="#“双1”配置" class="headerlink" title="“双1”配置"></a>“双1”配置</h3><p>通常我们说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。</p>
<p>mysql可以根据redolog prepare状态的持久化的日志+binlog进行崩溃恢复的</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="binlog组提交参数"><a href="#binlog组提交参数" class="headerlink" title="binlog组提交参数"></a>binlog组提交参数</h2><img src="https://gitee.com/leo_anna/image/raw/master/img//20211228221730.png" alt="img" style="zoom: 33%;" />

<p>参数：binlog_group_commit_sync_delay 和binlog_group_commit_sync_no_delay_count </p>
<ul>
<li>binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync;</li>
<li>binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</li>
</ul>
<p>这两个条件是或的关系，也就是说只要有一个满足条件就会调用 fsync。所以，当 binlog_group_commit_sync_delay 设置为 0 的时候，binlog_group_commit_sync_no_delay_count 也无效了。</p>
<h2 id="丢失数据场景分析"><a href="#丢失数据场景分析" class="headerlink" title="丢失数据场景分析"></a>丢失数据场景分析</h2><ol>
<li>大促期间吗，设置的是sync_binlog=0和innodb_flush_log_at_trx_commit=2<br>在主机重启时，会有几种风险:</li>
</ol>
<ul>
<li>如果事务的binlog和redo log都还未fsync,则该事务数据丢失</li>
<li>如果事务binlog fsync成功,redo log未fsync,则该事务数据丢失。虽然binlog落盘成功,但是binlog没有恢复redo log的能力,所以redo log不能恢复.<br>不过后续可以解析binlog来恢复这部分数据</li>
<li>如果事务binlog fsync未成功,redo log成功。由于redo log恢复数据是在引擎层,所以重新启动数据库,redo log能恢复数据,但是不能恢复server层的binlog,则binlog丢失。如果该事务还未从filesystem page cache里发送给从库,那么主从就会出现不一致的情况</li>
</ul>
<p>注意：filesystem page cache中的数据是可以读到的</p>
<ol start="2">
<li>设置sync_binlog = N，如果是<strong>主机异常重启</strong>，会丢失n条数据</li>
<li>redolog：innodb_flush_log_at_trx_commit 设置2，会丢失数据</li>
</ol>
<h2 id="io瓶颈的优化"><a href="#io瓶颈的优化" class="headerlink" title="io瓶颈的优化"></a>io瓶颈的优化</h2><ul>
<li>组提交，设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li>
<li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。这样做的风险是，主机掉电时会丢 binlog 日志。</li>
<li>将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>redolog和binlog</tag>
        <tag>刷盘</tag>
        <tag>io瓶颈</tag>
      </tags>
  </entry>
</search>
